## 1、初识C语言

25年了，还学C语言咩？

没办法，C语言更接近底层，且日后逆向中使用IDA Pro等工具的时候，反编译器会尽可能的把汇编转成伪C代码
若不会C语言，那么看这些伪C代码的时候，会非常的吃力

环境搭建则选择Windows + MinGW-w64，或者选择Windows + Visual Studio 生成工具
编辑器仍然选择Visual Studio Code

```c
#include <stdio.h>

int main(){
    printf("Hello World\n");
    return 0;
}
```
创建第一个C代码
- #include <stdio.h> 这是一个预处理指令，告诉编译器，在编译前，把stdio.h文件的内容粘贴到这里，因为用到了printf
- int main()，main程序的入口，从这里开始执行，且int代表函数执行完返回一个int整数值
- printf()，调用的stdio.h里的函数，打印输出
- return 0，返回0给操作系统，表示一切正常

现在我们就要开始探索了
```bash
gcc 1.c -o hello
```
gcc编译器，-o输出可执行文件，直接键入hello.exe，即可运行程序

那么编译器到底做了什么？我们看着很简单的一句指令，其实做了四件事：
- 预处理，把#开头的指令替换成实际的文件内容，#define就进行宏文本替换，可以用gcc -E 1.c观察
- 编译，最核心的翻译步骤，把预处理后的C代码，翻译成和CPU架构相关，人类可阅读的汇编代码，gcc -S 1.c
- 汇编，把汇编代码，翻译成机器认识的纯二进制的目标文件，gcc -c 1.c
- 链接，把编译好的目标文件，和依赖的库文件，链接到一起，形成独立的可执行文件

C语言有两种注释，//和/**/单行和多行的区别
```c
// 这是一个单行注释，用来解释下面的变量用途。
int user_id = 1001;

/*
  这是一个多行注释。
  它可以用来写更详细的文档或暂时禁用一段代码。
  int is_admin = 1;  // 这行代码在多行注释中，不会被编译。
*/
```
给人看的，编译器会忽略，可以进行gcc -E看看，编译器会直接删掉

要使用变量，就要先声明，和Python不同，这个必须要写数据类型，数据类型 变量名 = 值;
```c
int age;      // 声明一个名为 age 的整型(integer)变量
double score; // 声明一个名为 score 的双精度浮点型(double)变量
char level;   // 声明一个名为 level 的字符型(character)变量
int age2 = 25;       // 还有这种初始化的方式

age = 25;           // 赋值
score = 95.5;
level = 'A';
```
我们写的时候是名字，但是编译后，就消失了，取而代之的是一个内存地址，比如rbp-4
```Assemble
mov     dword ptr [rbp - 4], 25
```
类型的话就是这块内存占用多大的空间，比如int类型，4个字节，决定分配多大空间，CPU如何操作

这里我把#define提前，这个就纯是文本替换
```c
#define PI 3.14159
#define MAX(a, b) ((a) > (b) ? (a) : (b))

double cir = radius * radius * PI;
int larger_num = MAX(x, y);
```
这里看着高大上，迷迷糊糊，让我们编译下，gcc -E 3.c -o 3.i
```c
double cir = radius * radius * 3.14159;
int larger_num = ((x) > (y) ? (x) : (y));
```
可以看到，起始就是把宏定义的内容替换下来了，所以很多东西的本质很简单，只是形式唬人

至于printf，在win和linux 都是64位的前提下，函数的前几个参数通常都是寄存器传递，所以printf有可能就是：
```Assemble
lea rdi, [rip + str] ; 把字符串地址加载到rdi
...
call printf ; 调用函数
```

我们再来解剖下，int和double，在内存一样吗？比如int a = 10; double b = 10.0;
可以先说结论，是完全不同，后面说到补码和IEEE编码就知道了，存储方式是不一样的

## 2、数据类型
计算机的内存很大，就像一个超大的折扣仓，无数个货架和货位组成，每个货位都有一个独一无二的编号

数据类型：内存的设计蓝图，其实数据类型的目的，就是为了告诉编译器：
- 这个变量要占用多少个字节的内存空间
- 如何解释这个内存空间里的0和1
C语言提供了sizeof函数，可以返回一个类型或者变量的占用字节数，sizeof是一个编译时操作符，也就是程序还没运行的时候，尺寸就已经确定下来了
```c
#include <stdio.h>

int main() {
    printf("Size of char:      %zu byte(s)\n", sizeof(char));
    printf("Size of short:     %zu byte(s)\n", sizeof(short));
    printf("Size of int:       %zu byte(s)\n", sizeof(int));
    printf("Size of long:      %zu byte(s)\n", sizeof(long));
    printf("Size of long long: %zu byte(s)\n", sizeof(long long));
    printf("Size of float:     %zu byte(s)\n", sizeof(float));
    printf("Size of double:    %zu byte(s)\n", sizeof(double));
    return 0;
}
```
执行这个代码，sizeof返回的是size_t类型，所以打印最标准的格式化符号是%zu
会输出如下内容：
```bash
Size of char:      1 byte(s)
Size of short:     2 byte(s)
Size of int:       4 byte(s)
Size of long:      4 byte(s)
Size of long long: 8 byte(s)
Size of float:     4 byte(s)
Size of double:    8 byte(s)
```
这就是尺寸

还有一部分我们说了，就是编码
- char - 1字节，不仅仅是字符，还是一个小的整数
- int - 2、4、8字节，比如short、int、long、long long，使用补码的二进制编码表示正数、负数、零
- float/double - 4、8字节，使用IEEE 754标准的二进制编码表示浮点数，所以float和int都是4字节，但存储不同
最简单的，所以int和double占用的空间就不同，而且存储的方式也不同

常见的数据类型：
- 整数型
  - char 1字节，也是一个小范围的整数
  - short 2字节
  - int 4字节
  - long long 8字节
- 浮点的
  - float 4字节
  - double 8字节

数据类型最重要的作用：指导编译器选择正确的CPU指令来处理数据，如下代码：
```c
void main() {
    char  var_char  = 0x11;
    short var_short = 0x2233;
    int   var_int   = 0x44556677;
}
```
生成一个32位汇编查看 gcc -S 2.c -o 2.s -m32
```Assemble
movb	$17, 15(%esp)
movw	$8755, 12(%esp)
movl	$1146447479, 8(%esp)
```
- char var_char -> movb
  - b代表byte 1字节，编译器因为char选择了字节操作指令
- short var_short -> movw
  - w代表word 2字节
- int var_int -> movl
  - l代表long，4字节 x86-32架构
也就是C语言的数据类型，决定了汇编层面操作数据的大小

包括在寄存器也有体现，比如EAX32、AX16、AH/AL8，CPU对数据运算的时候，也是根据数据类型的尺寸匹配，加再到寄存器的相同大小位置上

## 3、有无符号数与补码
前面学数据类型，知道了数据类型规定分配空间大小和指令操作大小，以及每个二进制位的解释方法
也提到了存储方式，比如补码和IEEE等，现在稍微看下补码

原码和反码就一带而过了，原码就是最高位符号位，其余位为数值(二进制)本身，反码就是符号位除外，其余取反
正数的原码和反码、补码都是一样的，所以只针对有符号数来

signed和unsigned也是如何解释的体现
- signed告诉编译器，这块内存区域的最高位，用作符号位，0位正数，1为负数
- unsigned也是，告诉编译器，这块区域的所有比特位，也就是二进制都用于表示数值，没有符号位的概念
所以光从概念我们就知道，unsigned的存储范围，必定比signed大
signed的表示范围从-2^n-1 到 (2^(n-1))-1，unsigned就是从0到2^n -1
带入一下，char 8位，-2^8-1次方 - 2^8-1次方-1，也就是-128 - 127，其他的一样

计算机采用补码的形式表示有符号数，补码的规则：
- 正数和零：就用自身的二进制表示
- 负数：补码为绝对值的二进制按位取反，最后+1
举例：
```c
#include <stdio.h>

void main(){
    signed char c = -5; // 绝对值5的二进制0000 0101
    // 取反1111 1010
    // +1 = 1111 1011，验证一下
    printf("%p",&c);
}

// 128  64  32  16  8  4  2  1
```
借助VC++6.0 或者 Visual Studio，内存追踪会看到下面的内容
0019FF2C  FB，FB就是1111 1011
比如经常看到的溢出
```c
#define BUFFER_SIZE 256

void process_data(char *user_input, int len) {
    char buffer[BUFFER_SIZE];

    if (len < BUFFER_SIZE) {
        printf("Length check passed. Copying %d bytes.\n", len);
        memcpy(buffer, user_input, len);
        printf("Copy finished.\n");
    } else {
        printf("Error: Input length %d is too large.\n", len);
    }
}
```
这里做个大概说明，看不懂没关系：
- 本意ben < BUFFER_SIZE，是为了防止溢出，但是如果我在传len的时候，传入-1
- -1肯定是小于256的，但是问题就出现在memcpy上，找到他的函数原型一看
```c
void *memcpy(
   void *dest,
   const void *src,
   size_t count
);
```
- 是个size_t，本质是一个unsigned无符号，但是因为这里是个负数，所以要补码，我们知道转完内存就是0xFFFFFFFF
- 那么0xFFFFFFFF被解释成unsigned，好了，问题出现了，此时就不是-1了，而是解析成2^32 -1，4,294,967,295
- 此时就会导致严重的溢出
所以，在处理任何大小、长度、容量等不允许出现负数的时候，优先使用无符号unsigned类型，避免隐患

unsigned和signed的汇编代码生成的时候也会不同熬，可以自己动手看一下

## 4、运算符
C语言的运算符有：
- 算数运算符
  - +，Add/Inc
  - -，Sub/Dec/Neg
  - *，Mul/Imul
  - /，Div
  - %，对应IDIV
- 逻辑运算符
  - &&
  - ||
  - !
- 位运算，结合例子，比如a = 0011 0101(53) 和 b = 1100 1010(202)
  - AND &，两个都为1，才为1，否则0
    - a&b = 0000 0000
  - OR |，有一个为1就为1
    - a&b = 1111 1111 = 255
  - XOR ^，相同为0，不同为1
    - 1111 1111
  - NOT ~，取反
    - ~a = 1100 1010
- 位移运算符
  - << 左移 SHL/SAL，比特位往左移动，右侧补0
    - a<<3 = 1010 1000
  - \>\> 右移 SHR/SAR，比特位右移
    - SHR逻辑右移用于unsigned，右移后左侧补0，a >> 3 = 0000 0110
    - SAR算数右移用于signed，左侧用原始符号位填充

## 5、流程控制
程序默认自上向下顺序执行，CPU里有个特殊的寄存器，指令指针就是EIP和RIP
始终指向下一条要执行的指令的内存地址上

所有的流程控制，本质都是在特定条件下修改EIP/RIP的值

比如if和switch等语句，后面会详细说，了解基础用法先
```c
int score = 85;
if (score >= 90) {
    printf("ok\n");
} else if (score >= 60) {
    printf("Pass\n");
} else {
    printf("Fail\n");
}
```

switch
```c
int command = 2;
switch (command) {
    case 1:
        printf("Start...\n");
        break; // break，否则会穿透下一个case
    case 2:
        printf("Stop...\n");
        break;
    case 3:
        printf("Restart...\n");
        break;
    default:
        printf("Unknown command.\n");
        break;
}
```

for
```c
for (int i = 0; i < 10; i++) {
    printf("%d ", i);
}
```

while
```c
int countdown = 5;
while (countdown > 0) {
    printf("%d...\n", countdown);
    countdown--;
}
```

do-while
```c
char input;
do {
    printf("Enter 'q' to quit: ");
    scanf(" %c", &input);
} while (input != 'q');
```

基本在汇编里看到：比较CMP，CMP a,b，本质=a-b但是不保存结果，然后设置EFLAGS的标志位
关键的标志位有：
- ZF(Zero Flag)，零标志，如果a-b=0，5+-5也一样，只要结果为0，也就是相等，ZF=1
- SF(Sign Flag)，符号位，结果为负数，那么SF=1，也就是最高有效位为1，最高位的拷贝，相当于a<b
- OF(Overflow Flag)，溢出标志，有符号结果溢出了，OF=1
- CF(Carry Flag)，进位标志，无符号运算，发生最高位进位。或者相减借位，CF=1，a<b

Jcc指令，就是检查EFLAGS标志位，进行跳转
- == - JE/JZ - ZF = 1 - jump if Equal，如果相等跳转
- != - JNE/JNZ - ZF = 0 - jump if not Equal，如果不相等跳转
- > - JG/JNLE - ZF=0,SF=OF - jump if Greater，如果大于
- < - JL/JNGE - SF!=OF - jump if Less, 如果小于
- \>\= - JGE/JNL - SF=OF - jump if Greater or Equal，如果大于等于
- \>\= - JLE/JNG - SF!=OF or ZF = 1 - jump if Less or Equal，如果小于等于
- JA/JNBE - CF=0,ZF=0 - jump if Above，如果大于
- JB/JNAE - CF=1 - jump if Below，如果小于
- JMP - 无条件跳转

循环最明显的特征就是是否有一个指向上方地址的条件跳转

### 5.1、if语句
C语言的if语句查看
```c
#include <stdio.h>

void main(){
	int a = 0;
	int x= 0;
    if (a > 10) {
		x = 1;
	} else {
		x = 2;
	}
	return 0;
}
```
然后转到汇编看，可以看我的，可以自己用VC++6.0看，或者gcc输出
```Assemble
6:        if (a > 10) {
00401096 83 7D FC 0A          cmp         dword ptr [ebp-4],0Ah
0040109A 7E 09                jle         main+35h (004010a5)
```
比较ebp-4也就是a和0Ah，相当于做减法，jle = jump if less or equal，小于或者等于，也就是 a<=10的话跳转4010a5
```Assemble
9:            x = 2;
004010A5 C7 45 F8 02 00 00 00 mov         dword ptr [ebp-8],2
```
4010a5是什么，就是else代码块
只有a>10的时候，才会执行下面的紧跟着的代码块

一般汇编条件的跳转是C语言逻辑跳转的反转，比如a>10，会给你用jle，如果a<10，会用jge，为了跳过不应该执行的代码

### 5.2、switch语句
switch语句，重点结构，编译器会采用跳转表的方式
```c
switch(val) {
    case 0: funcA(); break;
    case 1: funcB(); break;
    case 2: funcC(); break;
    default: funcD(); break;
}
```
汇编
```Assemble
0040117F 8B 45 FC             mov         eax,dword ptr [ebp-4]
00401182 89 45 F8             mov         dword ptr [ebp-8],eax
00401185 83 7D F8 00          cmp         dword ptr [ebp-8],0
00401189 74 0E                je          main+39h (00401199)
0040118B 83 7D F8 01          cmp         dword ptr [ebp-8],1
0040118F 74 0F                je          main+40h (004011a0)
00401191 83 7D F8 02          cmp         dword ptr [ebp-8],2
00401195 74 10                je          main+47h (004011a7)
00401197 EB 15                jmp         main+4Eh (004011ae)
```
看上面，ebp-4是变量val，然后把数据又放到了ebp-8，最后cmp比较，0和ebp-8是否相等，je就是jump if equal，如果相等跳转到401199，后面一样，一直在比较
这是比较少的时候，再多加几个，可以看看
```c
switch(val) {
		case 0: funcA(); break;
		case 1: funcB(); break;
		case 2: funcC(); break;
		case 3: funcD(); break;
		case 4: funcE(); break;
		case 5: funcF(); break;
		case 6: funcG(); break;
		case 7: funcH(); break;
		default: funcI(); break;
	}
```
如上，我加了一大堆，汇编会产生很大的变化
```Assemble
0040D8AF 8B 45 FC             mov         eax,dword ptr [ebp-4]
0040D8B2 89 45 F8             mov         dword ptr [ebp-8],eax
0040D8B5 83 7D F8 07          cmp         dword ptr [ebp-8],7
0040D8B9 77 42                ja          $L801+7 (0040d8fd)
0040D8BB 8B 4D F8             mov         ecx,dword ptr [ebp-8]
0040D8BE FF 24 8D 15 D9 40 00 jmp         dword ptr [ecx*4+40D915h]
$L801:
0040D8F6 E8 37 37 FF FF       call        @ILT+45(_funcH) (00401032)
0040D8FB EB 05                jmp         $L801+0Ch (0040d902)
0040D8FD E8 35 37 FF FF       call        @ILT+50(_funcI) (00401037)
0040D902 33 C0                xor         eax,eax
0040D904 5F                   pop         edi
```
分段来看
```Assemble
0040D8AF 8B 45 FC             mov         eax,dword ptr [ebp-4]
0040D8B2 89 45 F8             mov         dword ptr [ebp-8],eax
0040D8B5 83 7D F8 07          cmp         dword ptr [ebp-8],7
0040D8B9 77 42                ja          $L801+7 (0040d8fd)
0040D8BB 8B 4D F8             mov         ecx,dword ptr [ebp-8]
0040D8BE FF 24 8D 15 D9 40 00 jmp         dword ptr [ecx*4+40D915h]
```
ebp-4还是变量val，然后放入ebp-8，然后cmp ebp-8和7比较，本质就是8个判断，是7个，大于7肯定就是default,所以这种连续的就会取最大的
所以ja判断的就是大于7的话就调到default的地方
下一句是把ebp-8放到ecx，然后再去寻址\[ecx*4+40D915h\]，40D915h这是一个跳转表，可以自己去内存看，根据ecx的值，跳转到不同的地方
比如ecx=7,7*4+40D915h=40D931h，0x40D931的内存是0040D8F6，所以就会跳转到这里
```Assemble
$L801:
0040D8F6 E8 37 37 FF FF       call        @ILT+45(_funcH) (00401032)
0040D8FB EB 05                jmp         $L801+0Ch (0040d902)
```
基本上在逆向分析的时候，看到jmp [\base+index*xxx\]的时候，且能找到一个连续的地址存储，几乎就完全可以确定是一个switch语句

那么前面留了一个问题，如果非连续呢，比如从case 5，一下到了case 500、case 1000、case 10000呢
```c
	switch(val) {
		case 0: funcA(); break;
		case 1: funcB(); break;
		case 2: funcC(); break;
		case 3: funcD(); break;
		case 4: funcE(); break;
		case 500: funcF(); break;
		case 1000: funcG(); break;
		case 10000: funcH(); break;
		default: funcI(); break;
	}
```
此时和上面就是两个逻辑了，如果生成跳转表，会很浪费，会采用混合策略
比如0-4非常适合用跳转表，但是500、1000、10000是不紧密的，就要单独的处理
```Assemble
00401248 C7 45 FC 07 00 00 00 mov         dword ptr [ebp-4],7
0040124F 8B 45 FC             mov         eax,dword ptr [ebp-4]
00401252 89 45 F8             mov         dword ptr [ebp-8],eax
```
单独看，变量val=7放入了ebp-8
```Assemble
00401255 81 7D F8 F4 01 00 00 cmp         dword ptr [ebp-8],1F4h
0040125C 7F 19                jg          main+47h (00401277)
```
和500比较，如果jump if Greater大于则跳401277，1277是什么？
```Assemble
00401277 81 7D F8 E8 03 00 00 cmp         dword ptr [ebp-8],3E8h
0040127E 74 35                je          $L798+0Eh (004012b5)
```
这里就是1000，判断是否等于1000，是1000就跳4012b5
```Assemble
00401280 81 7D F8 10 27 00 00 cmp         dword ptr [ebp-8],2710h
00401287 74 33                je          $L798+15h (004012bc)
00401289 EB 38                jmp         $L798+1Ch (004012c3)
```
否则就到了判断是否10000，满足就去4012bc，不满足就去default了

接着回到500比较那里看
```Assemble
0040125E 81 7D F8 F4 01 00 00 cmp         dword ptr [ebp-8],1F4h
00401265 74 47                je          $L798+7 (004012ae)
```
继续判断是否等于500，如果等于到4012ae，也就是500的分支
```Assemble
00401267 83 7D F8 04          cmp         dword ptr [ebp-8],4
0040126B 77 56                ja          $L798+1Ch (004012c3)
0040126D 8B 4D F8             mov         ecx,dword ptr [ebp-8]
00401270 FF 24 8D DB 12 40 00 jmp         dword ptr [ecx*4+4012DBh]
```
继续判断是否大于4，大于跳4012c3，不然就去对应的跳转表，c3就到default了，因为大于4的话，就没有满足的条件了，最开始就判断了500、1000和10000了


### 5.3、循环语句
```c
#include <stdio.h>

void main(){
    for (int i = 0; i < 10; i++) {
    // 循环体...
	}
	return 0;
}
```
循环结构，无论在c还是汇编，都分为四个标准
```Assemble
0040DA58 C7 45 FC 00 00 00 00 mov         dword ptr [ebp-4],0
0040DA5F C7 45 F8 00 00 00 00 mov         dword ptr [ebp-8],0
0040DA66 C7 45 FC 00 00 00 00 mov         dword ptr [ebp-4],0
0040DA6D EB 09                jmp         main+38h (0040da78)
0040DA6F 8B 45 FC             mov         eax,dword ptr [ebp-4]
0040DA72 83 C0 01             add         eax,1
0040DA75 89 45 FC             mov         dword ptr [ebp-4],eax
0040DA78 83 7D FC 0A          cmp         dword ptr [ebp-4],0Ah
0040DA7C 7D 0B                jge         main+49h (0040da89)
0040DA7E 8B 4D F8             mov         ecx,dword ptr [ebp-8]
0040DA81 83 C1 01             add         ecx,1
0040DA84 89 4D F8             mov         dword ptr [ebp-8],ecx
0040DA87 EB E6                jmp         main+2Fh (0040da6f)
```
- 初始化40DA58位置初始化
- cmp dword ptr [ebp-4],0Ah，判断
- 循环体，0040DA7E和A84的位置
- 40DA6D和40DA6F进行i++

while可以自己打开汇编查看
```c
#include <stdio.h>

int main(){
	int i = 0;
    while(i<10){
		i += 1;
	}
	return 0;
}
```

```Assemble
0040DA58 C7 45 FC 00 00 00 00 mov         dword ptr [ebp-4],0
0040DA5F 83 7D FC 0A          cmp         dword ptr [ebp-4],0Ah
0040DA63 7D 0B                jge         main+30h (0040da70)
0040DA65 8B 45 FC             mov         eax,dword ptr [ebp-4]
0040DA68 83 C0 01             add         eax,1
0040DA6B 89 45 FC             mov         dword ptr [ebp-4],eax
0040DA6E EB EF                jmp         main+1Fh (0040da5f)
```
一样，初始化，比较，循环体代码

## 6、九九表
```c
#include <stdio.h>

int main() {
    int i, j;
	
    for (i = 1; i <= 9; i++) {
        for (j = 1; j <= i; j++) {
            printf("%d*%d=%-2d  ", j, i, i * j);
        }
        printf("\n");
    }
    return 0;
}
```
这个程序是简单的，练习循环的知识点
意思：
- 第一层循环，循环9次，比如第一次循环进入
- 到了内部循环，开始循环，然后成了1*1=1，完事了，打印换行
- 第二次i = 2了，又开始1\*1 和 1\*2了，然后再换行
- 以此类推，完成了乘法表

gcc -g 00006.c -o tb，-g加入调试信息，-O0，禁止编译器优化，而后拖入ida，查看main函数，空格查看汇编
一段段拆解
```Assemble
.text:000000014000145D                 mov     [rbp+i], 1
.text:0000000140001464                 jmp     short loc_1400014AB
```
给i初始化，1，然后跳转
```Assemble
.text:00000001400014AB                 cmp     [rbp+i], 9
.text:00000001400014AF                 jle     short loc_140001466
```
和9比较，jle = jump if less or equal，小于等于9，跳转loc_140001466
```Assemble
.text:0000000140001466                 mov     [rbp+j], 1
.text:000000014000146D                 jmp     short loc_140001495
```
给j初始化，然后跳转
```Assemble
.text:0000000140001495                 mov     eax, [rbp+j]
.text:0000000140001498                 cmp     eax, [rbp+i]
.text:000000014000149B                 jle     short loc_14000146F
.text:000000014000149D                 mov     ecx, 0Ah        ; Character
.text:00000001400014A2                 call    putchar
.text:00000001400014A7                 add     [rbp+i], 1
```
开始内部比较了，把j的值给eax，然后比较和i，如果jle小于等于，就跳转loc_14000146F，如果比i大了，就把ecx赋值0xA给ecx，然后putchar，ASCII里，0xA为换行符，然后i+1
+1完事之后，又是去和9比较那里了
```Assemble
.text:000000014000146F loc_14000146F:                          ; CODE XREF: main+4B↓j
.text:000000014000146F                 mov     eax, [rbp+i]
.text:0000000140001472                 imul    eax, [rbp+j]
.text:0000000140001476                 mov     ecx, eax
.text:0000000140001478                 mov     r8d, [rbp+i]
.text:000000014000147C                 mov     edx, [rbp+j]
.text:000000014000147F                 lea     rax, Format     ; "%d*%d=%-2d  "
.text:0000000140001486                 mov     r9d, ecx
.text:0000000140001489                 mov     rcx, rax        ; Format
.text:000000014000148C                 call    printf
.text:0000000140001491                 add     [rbp+j], 1
```
如果刚才j比i小或等于，到这里就是i的值给eax,然后i*j，然后结果到ecx
下面就开始给prntf传参准备了，mov r8d, rbp+i这里，就是把i的值放入r8d
然后j的值放入edx，然后format字符串地址放入rax，注意是地址
这样i、j、和format字符串都有了，还有一个ecx里存放的乘法的结果，放入r9d
然后把rax里存放的格式化字符串的地址放入rcx，最后调用printf输出
最后j+1，然后又是和i比较那一套
全完事就是这堆：
```Assemble
.text:00000001400014B1                 mov     eax, 0
.text:00000001400014B6                 add     rsp, 30h
.text:00000001400014BA                 pop     rbp
.text:00000001400014BB                 retn
.text:00000001400014BB main            endp
```
这里就是清空和恢复堆栈了

### 修改的趣味
- gdb 1.exe，开始调试程序
- b main，入口处下一个断点
- run ，开始执行，此时不出意外，会到main的第一行代码
- disassemble main，查看main函数的汇编
- 然后我们查找比较j和i的地方，也就是
```Assemble
   0x00007ff780b41498 <+72>:    cmp    -0x4(%rbp),%eax
   0x00007ff780b4149b <+75>:    jle    0x7ff780b4146f <main+31>
```
- 记录jle地址，下断，b *0x00007ff780b4149b
- c 继续执行，就会断在这了
- set {unsigned char}0x00007ff780b4149b = 0x7F，原来是7E，j<\=i，被改成了jg，也就是j>i
- delete 2，删除断点
- c，继续执行
看看输出的变化，和不改的都时候的变化

## 7、强者的指针世界
### 7.1、重识变量和内存
我们看了代码了，也看过值了，但是我们说过，变量存在内存，在内存就要有地址编号
指针就是专门处理地址的工具

指针的本质也是一个变量，但是存储的不是基本数据类型了，而是一个地址

先认识两个运算符：
- &，取地址运算符
- *，解引用运算符

先看代码例子
```c
#include <stdio.h>

int main() {
    int a = 10;
    int *p;    // 指针变量 p

    p = &a;    // 现在 p 指向 a。

    printf("变量 a 的值: %d\n", a);
    printf("变量 a 的地址: %p\n", &a);
    printf("指针 p 存储的值 (即a的地址): %p\n", p);
    printf("通过指针 p 获取 a 的值 (*p): %d\n", *p);
    *p = 20;
    printf("修改后，变量 a 的值: %d\n", a);

    return 0;
}
```
运行先看看
```bash
变量 a 的值: 10
变量 a 的地址: 0000006512BFF764
指针 p 存储的值 (即a的地址): 0000006512BFF764
通过指针 p 获取 a 的值 (*p): 10
修改后，变量 a 的值: 20
```
- *p = a的值，p = a的地址，修改\*p相当于修改了a
然后又回到一个很基础的问题，那么既然是一个地址，为什么还得int\* char*这样，直接搞一个通用的\*不行吗
当然......不行，指针的类型和数据类型一样，决定操作多少字节，决定解释方式
比如解引用，*p的时候，是从这个地址读4个还是1个啊？计算机得清楚
指针运算的时候，走一步的步长是4还是1？


```c
int main() {
    int var = 0x12345678;
    int *ptr = &var;
    int val_from_ptr = *ptr;
    return 0;
}
```
多说无益，look汇编：
```Assemble
mov     DWORD PTR [rbp-16], 305419896
```
给val开DWORD四字节空间且赋值
```Assemble
lea     rax, [rbp-16]
mov     QWORD PTR [rbp-8], rax
```
val的地址放入rax，然后给ptr
```Assemble
mov     rax, QWORD PTR [rbp-8]
mov     eax, DWORD PTR [rax]
mov     DWORD PTR [rbp-12], eax
```
ptr的值给rax，也就是var的地址，然后把地址里的内容给eax，然后放入val_from_ptr

所以，看完汇编，指针其实就是个变量吗，只不过存了个地址而已
取地址符&，也就是lea是取地址常见的实现，只把地址获取，不获取内容喔
*解引用，就像mov eax, DWORD PTR \[rax\]，告诉电脑，不要给我本身的内容，我要你把rax当一个地址，然后取他里面的内容，就取DWORD字节

### 7.2、指针的运算
前面说到，既然指针和普通变量没区别，那么我的++ -- 和+1+2等，是否也能用？
可以是可以，但是是有规则的，和普通的运算的区别在于：编译器会根据指针的类型，对运算进行**缩放**

啥啊，听了一头懵，其实就是ptr+n不是简单的ptr+n
他是ptr + n*sizeof(\*ptr)

上案例：
```c
#include <stdio.h>

int main() {
    int arr[3] = {100, 200, 300}; // 数组，先别管
    int *p_int = &arr[0];
    char *p_char = (char*)arr; // 强制转换为 char*

    printf("--- 整型指针 (sizeof(int) = %zu) ---\n", sizeof(int));
    printf("p_int 的地址: %p\n", p_int);
    p_int++;
    printf("p_int++ 后的地址: %p\n", p_int);

    printf("\n--- 字符指针 (sizeof(char) = %zu) ---\n", sizeof(char));
    printf("p_char 的地址: %p\n", p_char);
    p_char++;
    printf("p_char++ 后的地址: %p\n", p_char);

    return 0;
}
```
看输出
```bash
--- 整型指针 (sizeof(int) = 4) ---
p_int 的地址: 000000B0065FF6F4
p_int++ 后的地址: 000000B0065FF6F8

--- 字符指针 (sizeof(char) = 1) ---
p_char 的地址: 000000B0065FF6F4
p_char++ 后的地址: 000000B0065FF6F5
```
pint++，加了4，pchar++加了1，也就是指针每次的步长，由自己本身的类型决定

```c
int arr[10];
int i = 5;
int val = arr[i];
```
汇编
```Assemble
mov     DWORD PTR [rbp-4], 5
mov     eax, DWORD PTR [rbp-4]
cdqe
mov     eax, DWORD PTR [rbp-48+rax*4]
mov     DWORD PTR [rbp-8], eax
```
首先，mov rbp-4,5，就是i = 5，然后又把5放入了eax
然后cdqe把eax转为rax
然后重点开始寻址，rbp-48就是数组的起始地址base，rax就是偏移量i，4就是缩放因子
如果在逆向里看到这样类似的，\*2、\*4、\*8等，几乎就可以断定是个数组或者类似结构

两个一样的指针可以相减，结果不是地址之间的差，是元素之间相差的个数
```c
int main(){
    int arr[10];
    int *p1 = &arr[2];
    int *p2 = &arr[7];

    long long diff = p2 - p1;
    return 0;
}
```
此时diff会是5
```c
(gdb) p diff
$1 = 5
```
自己去验证


### 7.3、指针语法糖
为后面的数组打个铺垫，有一个至关重要的话，数组的名称，会自动变为一个指向首元素的指针

那么数组名称是指向首元素的指针，就可以根据运算规则
- arr + i = 从arr开始的第i个元素
- *(arr+i)，对第i个元素的地址取值
arr\[i\]的本质就是如此，只不过为了方便我们来查看，方便我们使用查看的，就是语法糖

验证结论，编写代码
```c
int main() {
    int arr[5] = {10, 20, 30, 40, 50};
    int val1 = arr[2];       // 写法1：数组下标
    int val2 = *(arr + 2);   // 写法2：指针运算
    return val1 + val2;
}
```
汇编
```Assemble
mov     DWORD PTR [rbp-32], 10
mov     DWORD PTR [rbp-28], 20
mov     DWORD PTR [rbp-24], 30
mov     DWORD PTR [rbp-20], 40
mov     DWORD PTR [rbp-16], 50
```
第一句，不用看，很简单
```Assemble
mov     eax, DWORD PTR [rbp-24]
mov     DWORD PTR [rbp-4], eax

mov     eax, DWORD PTR [rbp-24]
mov     DWORD PTR [rbp-8], eax
```
看这两句，一个数组下标，一个指针运算，都一样的在汇编上，就是写法不同


但是有例外，有时候数组名不是指针，比如被sizeof的时候
&array的时候，返回指向整个数组的指针
```c
int arr[10];
int *p1 = arr;

int (*p2)[10] = &arr;
```
地址相等，但是自己实验加法运算看看，p1会到下一个元素，而p2直接往后+40

### 7.4、多级指针

还是延伸前面的，int val=100，此时普通变量val = 100
int* p = &val 一级指针，p指向val的地址
int*\* pp = &p 二级指针，pp指向p的地址
int*\*\* ppp = &pp 三级指针
*的个数决定了解引用多少次才能拿到最终数据

```c
#include <stdio.h>

int main() {
    int var = 100;
    int *p = &var;
    int **pp = &p;
    int ***ppp = &pp;

    printf("p 的地址 (pp的值):  %p\n", pp);
    printf("pp 的地址 (ppp的值): %p\n", ppp);

    printf("Value of var: %d\n", var);

    printf("Via *p: %d\n", *p);

    printf("Via **pp: %d\n", **pp);

    printf("Via ***ppp: %d\n", ***ppp);

    **pp = 200;
    printf("New value of var: %d\n", var);

    return 0;
}
```
输出
```bash
p 的地址 (pp的值):  000000AE5CBFF6E8
pp 的地址 (ppp的值): 000000AE5CBFF6E0
Value of var: 100
Via *p: 100
Via **pp: 100
Via ***ppp: 100
New value of var: 200
```
用途呢，用在哪？
```c
#include <stdlib.h> // for malloc

// 错误示范：无法修改外部的ptr
void allocate_memory_wrong(int *ptr) {
    ptr = (int*)malloc(sizeof(int));
}

// 正确示范：通过二级指针修改外部的ptr
void allocate_memory_correct(int **ptr_addr) {
    *ptr_addr = (int*)malloc(sizeof(int)); // 拿到指针my_ptr的地址，解开一层，申请内存空间
}

int main() {
    int *my_ptr = NULL; // 指向空
    allocate_memory_correct(&my_ptr); // 调用后 my_ptr 指向了新分配的内存
    if (my_ptr != NULL) {
        *my_ptr = 555;
        free(my_ptr);
    }
    return 0;
}
```
一个用于函数中修改指针本身
其他用途后面再说


看汇编，错误的写法：
```Assemble
mov     QWORD PTR [rbp-8], rdi
mov     edi, 4
call    malloc
mov     QWORD PTR [rbp-8], rax
``
最后rax又给了rbp-8，如果你觉得这是对的，没关系，因为还没正八经的学习汇编
但是这里是不对的，因为这个rbp-8是allocate_memory_wrong函数自己的栈帧上的一个局部变量，并没有修改到main函数的栈帧上去，函数返回后，这个变量就失效了

看正确的呢
```Assemble
mov     QWORD PTR [rbp-8], 0
lea     rax, [rbp-8]
mov     rdi, rax
call    allocate_memory_correct(int**)
```
首先NULL给my_ptr，然后取my_ptr地址给rax，然后rax给rdi作为参数，传入函数
```Assemble
mov     QWORD PTR [rbp-8], rdi
mov     edi, 4
call    malloc
mov     rdx, rax
mov     rax, QWORD PTR [rbp-8]
mov     QWORD PTR [rax], rdx
```
rdi放到rbp-8函数的栈帧，然后edi赋值4，因为开一个int大小的内存空间，地址返回给rax
然后rax个rdx，然后栈帧上的rbp-8给rax，注意这里的rbp-8是指向my_ptr的指针
然后把rdx也就是新开辟的内存，给了\[rax\]也就是指向my_ptr的地址，所以my_ptr就指向了新开辟的内存

这就是多级指针的本质，很简单

### 7.5、数组的本质
首先，C语言本身没有一个独立的字符串类型，那是C++才有的，所以在C上，我们所说的str字符串，是一个约定
一会我们就会知道，其实就是一个以特殊的空字符\0结尾的字符数组，这个\0我们就知道，在内存里象征着字符串的结束

```c
#include <stdio.h>

int main(){
    char str1[] = "hello"; // 编译器给末尾自动+\0，所以实际占用6个字节
    str1[1] = 'H'; // 合法，是个数组，可以修改
    printf("%s",str1); // %s打印字符串
    return 0;
}
```

还有一种，指针的，指向只读区，不能修改的
```c
char *str2 = "world";
```
这个时候的world，成为字符串字面量，存储到程序的只读数据段，str2是个指针，指向这个首地址

还有一些常用的字符串函数，先包含<string.h>头文件
- strlen()，获取长度，不包括\0
- strcpy(dest,src)，拷贝，危险版本，把src拷贝到dest，包括\0，若dest小于src的长度，会导致溢出
- strncpy(dest,src,len)，拷贝，安全版本，len可以现在长度，比如sizeof(dest)-1，因为留一个给\0用
- strcmp()，比较字符串，因为if str1==str2，比较的是两个指针的地址，不是字符串内容strcmp(s1,s2)==0可以，>0则s1>s2，反之
可以试试，构造一个长度5的数组，但是不给\0留下地方，会输出什么
```c
#include <stdio.h>

int main(){
    char bad_str[5] = {'h', 'e', 'l', 'l', 'o'}; 
    printf("Bad string: %s\n", bad_str); 
    return 0;
}
```
可以自己思考下为什么


实现一个自己的strlen
```c
#include <stdio.h>

int my_strlen(const char* s){
    const char *start = s;
    while(*s != '\0'){
        s++; // 往前走一个字节
    }
    return s - start; // 指针相减，得到的是字节数
}

int main(){
    char bad_str[] = "Hello World"; 
    int length = my_strlen(bad_str);
    printf("string length: %d\n", length); 
    return 0;
}

```
还是看汇编
```Assemble
mov     QWORD PTR [rbp-24], rdi
mov     rax, QWORD PTR [rbp-24]
mov     QWORD PTR [rbp-8], rax
```
字符串首地址给rdi传参，也就是s
rdi给rbp-24内存，当前的指针
然后rbp-24地址的值给rax，rax再放到rbp-8，rbp-8就是start
现在相当于current_ptr和start_ptr都指向了s
```Assemble 
.L3:
mov     rax, QWORD PTR [rbp-24]
movzx   eax, BYTE PTR [rax]
test    al, al
je      .L2
```
把s当前的地址加载到rax，执行*s解引用，取Byte一字节，test比较\*s是否是 \0
如果是\0，跳转到.L2
如果不是\0，继续循环
```Assemble
.L2:
mov     rax, QWORD PTR [rbp-24]
sub     rax, QWORD PTR [rbp-8]
```
L2的汇编就是rbp-24地址的值给rax，然后用rbp-8地址的值也就是减去当前的值，得出差距，也就是return s-start

这是如果不是\0的话的汇编
```Assemble
add     QWORD PTR [rbp-24], 1
jmp     .L3
```
对rbp-24地址的值加1，然后跳转到.L3继续执行加载取值比较等


### 7.6、值传递\地址传递
参数是如何传递的，为啥有的可以在函数内修改，有的不行
从字面意思看，值传递，只是传递了一个值，相当于给函数传递了一个副本
函数内修改，也只是修改的函数内部，外部不受影响
```c
#include <stdio.h>

void modify_value(int x) {
    printf("函数内部，接收到的x = %d\n", x);
    x = 100; // 这里修改的是副本x，和外面的a无关
    printf("函数内部，x被修改为 = %d\n", x);
}

int main() {
    int a = 10;
    printf("调用前，main中的a = %d\n", a);
    modify_value(a);
    printf("调用后，main中的a = %d\n", a);
    return 0;
}
```
地址传递我们在多级指针提了一嘴，传递的不是变量的值，是变量的地址
```c
#include <stdio.h>

void modify_by_address(int *p) {
    printf("函数内部，接收到的地址是 %p\n", p);
    *p = 100;
    printf("函数内部，通过地址将值修改为 100\n");
}

int main() {
    int a = 10;
    printf("调用前，main中的a = %d\n", a);
    modify_by_address(&a); // 使用&操作符，将a的地址传递给函数
    printf("调用后，main中的a = %d\n", a); 
    return 0;
}
```
以及数组作为函数参数：当把数组作为参数，C总是会隐式的执行地址传递
```c
#include <stdio.h>

void modify_array(int arr[], int size) {
    for (int i = 0; i < size; i++) {
        arr[i] = arr[i] * 10;
    }
}

int main() {
    int my_arr[3] = {1, 2, 3};
    modify_array(my_arr, 3);
    printf("调用后，数组内容为: %d, %d, %d\n", my_arr[0], my_arr[1], my_arr[2]);
    return 0;
}
```
传递my_arr数组，相当于传递了&my_arr\[0\]，会修改到本身

研究汇编：
```Assemble
mov     DWORD PTR [rbp-4], 10
mov     eax, DWORD PTR [rbp-4]
mov     edi, eax
call    modify_value(int)
```
至于第一个函数就光看这几句就行了，10给rbp-4地址，也是给了a
然后把值取出来给了eax，然后给edi，传入值，所以并改变不到本身


地址传递
```Assemble
mov     DWORD PTR [rbp-4], 10
lea     rax, [rbp-4]
mov     rdi, rax
call    modify_by_address(int*)
```
大差不差，10给a，然后lea取a的地址给rax，然后给rdi传参，调用，所以修改的是本身

数组的：
```Assemble
mov     DWORD PTR [rbp-12], 1
mov     DWORD PTR [rbp-8], 2
mov     DWORD PTR [rbp-4], 3
```
数组的初始化
```Assemble
lea     rax, [rbp-12]
mov     esi, 3
mov     rdi, rax
call    modify_array(int*, int)
```
取首元素的地址lea，然后大小3给esi，地址给rdi传参，然后调用

### 7.7、栈帧、调用约定、返回地址
对于写程序来说，result = func(a,b)天经地义的，但是如果我们要剖析底层来说，这个动作背后需要一个东西，就是栈(Stack)

栈是一个特殊的内存区域，后进先出，就像往一个单开口的桶里放东西，最后放进去的，肯定第一个取出来，栈主要用于管理函数调用

栈帧呢？比如当main调用funcA、然后funcA又调用了funcB，它们在内存里不能乱作一团，每个函数都得有自己的独立的工作空间，存储自己的局部变量和参数

栈帧（活动记录）就是函数被调用的时候，在栈上专门为这个函数分配的一块内存区域
一个典型的栈帧包括：
- 函数参数
- 返回地址
- 旧的栈帧基址：调用者函数的栈帧基址
- 局部变量

如下代码：
```c
int add(int x, int y) {
    int sum = x + y;
    return sum;
}

int main() {
    int result = add(10, 20);
    return 0;
}
```
看汇编
```Assemble
mov     edx, 14h        ; y
mov     ecx, 0Ah        ; x
call    add             ; Call Procedure
mov     [rbp+result], eax
```
这里用ida查看汇编，大概跟着流程走一下，从脑子里过一次
- 准备好10和20的参数x和y，调用函数add
- 执行call的时候，call的下一行指令的地址压入栈顶，然后程序到add的代码区
```Assemble
push    rbp
mov     rbp, rsp
sub     rsp, 10h
```
到了add函数的代码区，这一块都在开始建立自己的栈帧，分配空间
```Assemble
mov     [rbp+x], ecx
mov     [rbp+y], edx
mov     edx, [rbp+x]
mov     eax, [rbp+y]
add     eax, edx
```
取出参数，相加
```Assemble
mov     [rbp+sum], eax
mov     eax, [rbp+sum]
```
存入，在eax返回
```Assemble
add     rsp, 10h
pop     rbp
retn
```
销毁自己的栈帧，pop返回地址，ret执行返回，又回到main函数里
```
mov     [rbp+result], eax
```
然后取走eax的结果，存入result

说那么多，把涉及到的寄存器再说一遍，自己回去再从脑子里过一遍
- RSP/ESP，栈顶指针，始终指向栈的最顶部，地址动态变化，PUSH入栈，RSP/ESP减小，POP出栈，RSP/ESP增大，栈是向低地址方向增长的
- RBP/EBP，栈基址指针，在一个函数执行期间，通常被设定一个固定地址，指向函数栈帧底部，函数所有的变量和参数，都可以通过EBP/RBP+偏移进行访问，作为一个锚点

```Assemble
push    rbp ;备份
mov     rbp, rsp ;设定锚点
sub     rsp, 10h ;扩张空间
...
add     rsp, 10h ;恢复空间
pop     rbp ;恢复备份
retn ;返回
```
这个格式模板是很常见的，所有的函数开始和结束的时候，基本都是这样
有时候结尾还会看到leave ret
```Assemble
mov rsp,rbp
pop rbp
```
leave就相当于这两句，把rsp/esp拉回去，然后恢复rbp/ebp

gdb测试：
```bash
b main
run
info registers rbp rsp
rbp            0x5ffea0            0x5ffea0
rsp            0x5ffe70            0x5ffe70
```
此时记录了ebp和rsp
继续disas查看本身的汇编
```bash
=> 0x00007ff7ad1e147f <+13>:    mov    $0x14,%edx
   0x00007ff7ad1e1484 <+18>:    mov    $0xa,%ecx
   0x00007ff7ad1e1489 <+23>:    call   0x7ff7ad1e1450 <add>
   0x00007ff7ad1e148e <+28>:    mov    %eax,-0x4(%rbp)
```
看到了call下面的地址，然后si执行几次，到add函数处
```base
x/gx $rsp 查看栈顶，正好就是8e的地址
=> 0x00007ff7ad1e1450 <+0>:     push   %rbp
```
继续si单步，执行push rbp
```bash
x/2gx $rsp
0x5ffe60:       0x00000000005ffea0      0x00007ff7ad1e148e
```
又入栈一个
```bash
   0x00007ff7ad1e1451 <+1>:     mov    %rsp,%rbp
=> 0x00007ff7ad1e1454 <+4>:     sub    $0x10,%rsp

rbp            0x5ffe60            0x5ffe60
rsp            0x5ffe60            0x5ffe60
```
建立锚点，提升空间,rbp和rsp相等了
```bash
(gdb) info registers rbp rsp
rbp            0x5ffe60            0x5ffe60
rsp            0x5ffe50            0x5ffe50
```
rsp提升了，栈帧建立了

还有一个调用约定，细心的话可以看到这里：
```Assemble
int add(int x, int y) {
    int sum = x + y;
    return sum;
}

mov     edx, 14h        ; y
mov     ecx, 0Ah        ; x
call    add             ; Call Procedure
```
- x86-64下，macos、linux等，前6个整型参数或者指针参数会依次放入RDI、RSI、RDX、RCX、R8、R9，第7个开始入栈
- x86-32下，cdecl，从右到左入栈，返回值在eax，caller调用者清栈，call指令后紧跟着add
- x86-32 stdcall，从右到左参数入栈，返回值在eax，被调用者callee负责在ret之前清栈，ret n
- fastcall，前两个参数用ecx和edx，其余的从右到左入栈，被调用者callee在ret前清栈，call前，又mov ecx和mov edx赋值，ret n清理

### 7.8、函数指针
指针是存储数据地址的变量，在内存里，函数也有地址
但是，是一个特殊类型的指针，不指向数据，而是指向一个函数在内存里的起始地址

int* p，存储了一个数据的地址
void (*p)()，存储了一个函数的地址

这样可以让我们在程序运行的时候，动态决定调用哪个函数

```c
int add(int x, int y) {
    int sum = x + y;
    return sum;
}

int main() {
    // 声明方法：返回类型 (*指针变量名称)(参数类型的列表)
    // 注意*myadd两侧有括号 
    // int* myadd(int,int)，就成了myadd是个函数，返回int*类型了
    int (*myadd)(int,int);
    myadd = add; // &add也行

    int result = myadd(10,20);
    // int result = (*myadd)(10,20); //也可以，上面的是隐式写法
    return 0;
}
```

以及用来实现回调函数，也就是把函数a作为参数传给函数b，让b在需要的时候，回过头来调用a
```c
#include <stdio.h>

int add(int a, int b) { return a + b; }
int subtract(int a, int b) { return a - b; }

void calculator(int x, int y, int (*operation)(int, int)) {
    int result = operation(x, y);
    printf("The result of the operation is: %d\n", result);
}

int main() {
    calculator(20, 10, add); 
    calculator(20, 10, subtract);
    return 0;
}
```
在汇编里，普通函数的调用和函数指针的调用，是不同的，普通函数都看了，看看函数指针的，一般普通函数的调用就是call跟着一个固定的地址，编译的时候就确定了
```Assemble
call    __main
lea     rax, add
mov     [rbp+var_8], rax
mov     rax, [rbp+var_8]
mov     edx, 14h
mov     ecx, 0Ah
call    rax
```
call后面跟着一个间接的或者rax等寄存器的，这就是函数指针的，上面很清楚，add函数地址给rax等等，然后最后call rax

看到call rax或者间接的需要计算的call的时候，无非就是两个情况，优先怀疑：
- C语言函数指针调用
- C++虚函数调用，因为底层也是函数指针实现
