## 初识C语言

25年了，还学C语言咩？

没办法，C语言更接近底层，且日后逆向中使用IDA Pro等工具的时候，反编译器会尽可能的把汇编转成伪C代码
若不会C语言，那么看这些伪C代码的时候，会非常的吃力

环境搭建则选择Windows + MinGW-w64，或者选择Windows + Visual Studio 生成工具
编辑器仍然选择Visual Studio Code

```c
#include <stdio.h>

int main(){
    printf("Hello World\n");
    return 0;
}
```
创建第一个C代码
- #include <stdio.h> 这是一个预处理指令，告诉编译器，在编译前，把stdio.h文件的内容粘贴到这里，因为用到了printf
- int main()，main程序的入口，从这里开始执行，且int代表函数执行完返回一个int整数值
- printf()，调用的stdio.h里的函数，打印输出
- return 0，返回0给操作系统，表示一切正常

现在我们就要开始探索了
```bash
gcc 1.c -o hello
```
gcc编译器，-o输出可执行文件，直接键入hello.exe，即可运行程序

那么编译器到底做了什么？我们看着很简单的一句指令，其实做了四件事：
- 预处理，把#开头的指令替换成实际的文件内容，#define就进行宏文本替换，可以用gcc -E 1.c观察
- 编译，最核心的翻译步骤，把预处理后的C代码，翻译成和CPU架构相关，人类可阅读的汇编代码，gcc -S 1.c
- 汇编，把汇编代码，翻译成机器认识的纯二进制的目标文件，gcc -c 1.c
- 链接，把编译好的目标文件，和依赖的库文件，链接到一起，形成独立的可执行文件

C语言有两种注释，//和/**/单行和多行的区别
```c
// 这是一个单行注释，用来解释下面的变量用途。
int user_id = 1001;

/*
  这是一个多行注释。
  它可以用来写更详细的文档或暂时禁用一段代码。
  int is_admin = 1;  // 这行代码在多行注释中，不会被编译。
*/
```
给人看的，编译器会忽略，可以进行gcc -E看看，编译器会直接删掉

要使用变量，就要先声明，和Python不同，这个必须要写数据类型，数据类型 变量名 = 值;
```c
int age;      // 声明一个名为 age 的整型(integer)变量
double score; // 声明一个名为 score 的双精度浮点型(double)变量
char level;   // 声明一个名为 level 的字符型(character)变量

age = 25;           // 赋值
score = 95.5;
level = 'A';

// 或者，初始化
int age = 25;
double score = 95.5;
char level = 'A';
```
我们写的时候是名字，但是编译后，就消失了，取而代之的是一个内存地址，比如rbp-4
类型的话就是这块内存占用多大的空间，比如int类型，4个字节，决定分配多大空间，CPU如何操作

这里我把#define提前，这个就纯是文本替换
```c
#define PI 3.14159
#define MAX(a, b) ((a) > (b) ? (a) : (b))

double cir = radius * radius * PI;
int larger_num = MAX(x, y);
```
这里看着高大上，迷迷糊糊，让我们编译下，gcc -E 3.c -o 3.i
```c
double cir = radius * radius * 3.14159;
int larger_num = ((x) > (y) ? (x) : (y));
```
可以看到，起始就是把宏定义的内容替换下来了，所以很多东西的本质很简单，只是形式唬人

我们再来解剖下，int和double，在内存一样吗？比如int a = 10; double b = 10.0;
可以先说结论，是完全不同

## 数据类型
数据类型：内存的设计蓝图，其实数据类型的目的，就是为了告诉编译器：
- 这个变量要占用多少个字节的内存空间
- 如何解释这个内存空间里的0和1
C语言提供了sizeof函数，可以返回一个类型或者变量的占用字节数，sizeof是一个编译时操作符，也就是程序还没运行的时候，尺寸就已经确定下来了
```c
#include <stdio.h>

int main() {
    printf("Size of char:      %zu byte(s)\n", sizeof(char));
    printf("Size of short:     %zu byte(s)\n", sizeof(short));
    printf("Size of int:       %zu byte(s)\n", sizeof(int));
    printf("Size of long:      %zu byte(s)\n", sizeof(long));
    printf("Size of long long: %zu byte(s)\n", sizeof(long long));
    printf("Size of float:     %zu byte(s)\n", sizeof(float));
    printf("Size of double:    %zu byte(s)\n", sizeof(double));
    return 0;
}
```
执行这个代码，sizeof返回的是size_t类型，所以打印最标准的格式化符号是%zu
会输出如下内容：
```bash
Size of char:      1 byte(s)
Size of short:     2 byte(s)
Size of int:       4 byte(s)
Size of long:      4 byte(s)
Size of long long: 8 byte(s)
Size of float:     4 byte(s)
Size of double:    8 byte(s)
```
这就是尺寸

还有一部分我们说了，就是编码
- char - 1字节，不仅仅是字符，还是一个小的整数
- int - 2、4、8字节，比如short、int、long、long long，使用补码的二进制编码表示正数、负数、零
- float/double - 4、8字节，使用IEEE 754标准的二进制编码表示浮点数，所以float和int都是4字节，但存储不同
最简单的，所以int和double占用的空间就不同，而且存储的方式也不同

数据类型最重要的作用：指导编译器选择正确的CPU指令来处理数据