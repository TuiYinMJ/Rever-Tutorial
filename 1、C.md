## 1、初识C语言

25年了，还学C语言咩？

没办法，C语言更接近底层，且日后逆向中使用IDA Pro等工具的时候，反编译器会尽可能的把汇编转成伪C代码
若不会C语言，那么看这些伪C代码的时候，会非常的吃力

环境搭建则选择Windows + MinGW-w64，或者选择Windows + Visual Studio 生成工具
编辑器仍然选择Visual Studio Code

```c
#include <stdio.h>

int main(){
    printf("Hello World\n");
    return 0;
}
```
创建第一个C代码
- #include <stdio.h> 这是一个预处理指令，告诉编译器，在编译前，把stdio.h文件的内容粘贴到这里，因为用到了printf
- int main()，main程序的入口，从这里开始执行，且int代表函数执行完返回一个int整数值
- printf()，调用的stdio.h里的函数，打印输出
- return 0，返回0给操作系统，表示一切正常

现在我们就要开始探索了
```bash
gcc 1.c -o hello
```
gcc编译器，-o输出可执行文件，直接键入hello.exe，即可运行程序

那么编译器到底做了什么？我们看着很简单的一句指令，其实做了四件事：
- 预处理，把#开头的指令替换成实际的文件内容，#define就进行宏文本替换，可以用gcc -E 1.c观察
- 编译，最核心的翻译步骤，把预处理后的C代码，翻译成和CPU架构相关，人类可阅读的汇编代码，gcc -S 1.c
- 汇编，把汇编代码，翻译成机器认识的纯二进制的目标文件，gcc -c 1.c
- 链接，把编译好的目标文件，和依赖的库文件，链接到一起，形成独立的可执行文件

C语言有两种注释，//和/**/单行和多行的区别
```c
// 这是一个单行注释，用来解释下面的变量用途。
int user_id = 1001;

/*
  这是一个多行注释。
  它可以用来写更详细的文档或暂时禁用一段代码。
  int is_admin = 1;  // 这行代码在多行注释中，不会被编译。
*/
```
给人看的，编译器会忽略，可以进行gcc -E看看，编译器会直接删掉

要使用变量，就要先声明，和Python不同，这个必须要写数据类型，数据类型 变量名 = 值;
```c
int age;      // 声明一个名为 age 的整型(integer)变量
double score; // 声明一个名为 score 的双精度浮点型(double)变量
char level;   // 声明一个名为 level 的字符型(character)变量

age = 25;           // 赋值
score = 95.5;
level = 'A';

// 或者，初始化
int age = 25;
double score = 95.5;
char level = 'A';
```
我们写的时候是名字，但是编译后，就消失了，取而代之的是一个内存地址，比如rbp-4
类型的话就是这块内存占用多大的空间，比如int类型，4个字节，决定分配多大空间，CPU如何操作

这里我把#define提前，这个就纯是文本替换
```c
#define PI 3.14159
#define MAX(a, b) ((a) > (b) ? (a) : (b))

double cir = radius * radius * PI;
int larger_num = MAX(x, y);
```
这里看着高大上，迷迷糊糊，让我们编译下，gcc -E 3.c -o 3.i
```c
double cir = radius * radius * 3.14159;
int larger_num = ((x) > (y) ? (x) : (y));
```
可以看到，起始就是把宏定义的内容替换下来了，所以很多东西的本质很简单，只是形式唬人

我们再来解剖下，int和double，在内存一样吗？比如int a = 10; double b = 10.0;
可以先说结论，是完全不同

## 2、数据类型
计算机的内存很大，就像一个超大的折扣仓，无数个货架和货位组成，每个货位都有一个独一无二的编号

数据类型：内存的设计蓝图，其实数据类型的目的，就是为了告诉编译器：
- 这个变量要占用多少个字节的内存空间
- 如何解释这个内存空间里的0和1
C语言提供了sizeof函数，可以返回一个类型或者变量的占用字节数，sizeof是一个编译时操作符，也就是程序还没运行的时候，尺寸就已经确定下来了
```c
#include <stdio.h>

int main() {
    printf("Size of char:      %zu byte(s)\n", sizeof(char));
    printf("Size of short:     %zu byte(s)\n", sizeof(short));
    printf("Size of int:       %zu byte(s)\n", sizeof(int));
    printf("Size of long:      %zu byte(s)\n", sizeof(long));
    printf("Size of long long: %zu byte(s)\n", sizeof(long long));
    printf("Size of float:     %zu byte(s)\n", sizeof(float));
    printf("Size of double:    %zu byte(s)\n", sizeof(double));
    return 0;
}
```
执行这个代码，sizeof返回的是size_t类型，所以打印最标准的格式化符号是%zu
会输出如下内容：
```bash
Size of char:      1 byte(s)
Size of short:     2 byte(s)
Size of int:       4 byte(s)
Size of long:      4 byte(s)
Size of long long: 8 byte(s)
Size of float:     4 byte(s)
Size of double:    8 byte(s)
```
这就是尺寸

还有一部分我们说了，就是编码
- char - 1字节，不仅仅是字符，还是一个小的整数
- int - 2、4、8字节，比如short、int、long、long long，使用补码的二进制编码表示正数、负数、零
- float/double - 4、8字节，使用IEEE 754标准的二进制编码表示浮点数，所以float和int都是4字节，但存储不同
最简单的，所以int和double占用的空间就不同，而且存储的方式也不同

数据类型最重要的作用：指导编译器选择正确的CPU指令来处理数据，如下代码：
```c
void main() {
    char  var_char  = 0x11;
    short var_short = 0x2233;
    int   var_int   = 0x44556677;
}
```
生成一个32位汇编查看 gcc -S 2.c -o 2.s -m32
```Assembly
movb	$17, 15(%esp)
movw	$8755, 12(%esp)
movl	$1146447479, 8(%esp)
```
- char var_char -> movb
  - b代表byte 1字节，编译器因为char选择了字节操作指令
- short var_short -> movw
  - w代表word 2字节
- int var_int -> movl
  - l代表long，4字节 x86-32架构
也就是C语言的数据类型，决定了汇编层面操作数据的大小

包括在寄存器也有体现，比如EAX32、AX16、AH/AL8，CPU对数据运算的时候，也是根据数据类型的尺寸匹配，加再到寄存器的相同大小位置上

## 3、有无符号数与补码
前面学数据类型，知道了数据类型规定分配空间大小和指令操作大小，以及每个二进制位的解释方法
也提到了存储方式，比如补码和IEEE等，现在稍微看下补码

signed和unsigned也是如何解释的体现
- signed告诉编译器，这块内存区域的最高位，用作符号位，0位正数，1为负数
- unsigned也是，告诉编译器，这块区域的所有比特位，也就是二进制都用于表示数值，没有符号位的概念
所以光从概念我们就知道，unsigned的存储范围，必定比signed大
signed的表示范围从-2^n-1 到 (2^(n-1))-1，unsigned就是从0到2^n -1
带入一下，char 8位，-2^8-1次方 - 2^8-1次方-1，也就是-128 - 127，其他的一样

计算机采用补码的形式表示有符号数，补码的规则：
- 正数和零：就用自身的二进制表示
- 负数：补码为绝对值的二进制按位取反，最后+1
举例：
```c
#include <stdio.h>

void main(){
    signed char c = -5; // 绝对值5的二进制0000 0101
    // 取反1111 1010
    // +1 = 1111 1011，验证一下
    printf("%p",&c);
}

// 128  64  32  16  8  4  2  1
```
借助VC++6.0 或者 Visual Studio，内存追踪会看到下面的内容
0019FF2C  FB，FB就是1111 1011
比如经常看到的溢出
```c
#define BUFFER_SIZE 256

void process_data(char *user_input, int len) {
    char buffer[BUFFER_SIZE];

    if (len < BUFFER_SIZE) {
        printf("Length check passed. Copying %d bytes.\n", len);
        memcpy(buffer, user_input, len);
        printf("Copy finished.\n");
    } else {
        printf("Error: Input length %d is too large.\n", len);
    }
}
```
这里做个大概说明，看不懂没关系：
- 本意ben < BUFFER_SIZE，是为了防止溢出，但是如果我在传len的时候，传入-1
- -1肯定是小于256的，但是问题就出现在memcpy上，找到他的函数原型一看
```c
void *memcpy(
   void *dest,
   const void *src,
   size_t count
);
```
- 是个size_t，本质是一个unsigned无符号，但是因为这里是个负数，所以要补码，我们知道转完内存就是0xFFFFFFFF
- 那么0xFFFFFFFF被解释成unsigned，好了，问题出现了，此时就不是-1了，而是解析成2^32 -1，4,294,967,295
- 此时就会导致严重的溢出
所以，在处理任何大小、长度、容量等不允许出现负数的时候，优先使用无符号unsigned类型，避免隐患

## 4、运算符
C语言的运算符有：
- 算数运算符
  - +
  - -
  - *，对应ADD、SUB、IMUL
  - /
  - %，对应IDIV
- 逻辑运算符
  - &&
  - ||
  - !
- 位运算，结合例子，比如a = 0011 0101(53) 和 b = 1100 1010(202)
  - AND &，两个都为1，才为1，否则0
    - a&b = 0000 0000
  - OR |，有一个为1就为1
    - a&b = 1111 1111 = 255
  - XOR ^，相同为0，不同为1
    - 1111 1111
  - NOT ~，取反
    - ~a = 1100 1010
- 位移运算符
  - << 左移 SHL/SAL，比特位往左移动，右侧补0
    - a<<3 = 1010 1000
  - \>\> 右移 SHR/SAR，比特位右移
    - SHR逻辑右移用于unsigned，右移后左侧补0，a >> 3 = 0000 0110
    - SAR算数右移用于signed，左侧用原始符号位填充

## 5、流程控制
